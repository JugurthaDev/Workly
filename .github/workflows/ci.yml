name: "Workly Pipeline • Build → Docker → Deploy"

on:
  push:
    branches: [ "main" ]

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: "1"
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: "1"
  SOLUTION_PATH: tp_aspire_samy_jugurtha/tp_aspire_samy_jugurtha.sln
  API_DOCKERFILE: tp_aspire_samy_jugurtha/tp_aspire_samy_jugurtha.ApiService/Dockerfile
  WEB_DOCKERFILE: tp_aspire_samy_jugurtha/tp_aspire_samy_jugurtha.WebApp/Dockerfile
  VERSION_BASE: "1.0"
  REGISTRY: ghcr.io

jobs:
  build:
    name: Build .NET solution
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Remove missing E2E project from solution (if absent)
        run: |
          set -e
          E2E="tp_aspire_samy_jugurtha/tp_aspire_samy_jugurtha.WebApp.E2E/tp_aspire_samy_jugurtha.WebApp.E2E.csproj"
          if [ ! -f "$E2E" ]; then
            echo "E2E project not found, removing from solution to unblock CI"
            dotnet sln "$SOLUTION_PATH" remove "$E2E" || true
          fi

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Restore
        run: dotnet restore "$SOLUTION_PATH"

      - name: Build
        run: dotnet build "$SOLUTION_PATH" -c Release --no-restore

  test:
    name: Test suite
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Remove missing E2E project from solution (if absent)
        run: |
          set -e
          E2E="tp_aspire_samy_jugurtha/tp_aspire_samy_jugurtha.WebApp.E2E/tp_aspire_samy_jugurtha.WebApp.E2E.csproj"
          if [ ! -f "$E2E" ]; then
            echo "E2E project not found, removing from solution to unblock CI"
            dotnet sln "$SOLUTION_PATH" remove "$E2E" || true
          fi

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: |
            nuget-${{ runner.os }}-

      - name: Restore
        run: dotnet restore "$SOLUTION_PATH"

      - name: Build
        run: dotnet build "$SOLUTION_PATH" -c Release --no-restore

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-v1

      - name: Install Playwright CLI
        run: dotnet tool update --global Microsoft.Playwright.CLI || dotnet tool install --global Microsoft.Playwright.CLI

      - name: Install Playwright browsers (only if Playwright project exists)
        run: |
          set -euo pipefail
          PW_PROJECTS=$(grep -rl --include="*.csproj" '<PackageReference Include="Microsoft.Playwright"' . || true)
          if [ -z "$PW_PROJECTS" ]; then
            echo "No Playwright .csproj found; skipping Playwright install."
            exit 0
          fi
          for p in $PW_PROJECTS; do
            echo "Installing Playwright browsers for $p"
            ~/.dotnet/tools/playwright install --with-deps -p "$p"
          done

      - name: Test
        run: dotnet test "$SOLUTION_PATH" -c Release --no-build --logger "trx;LogFileName=test-results.trx"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/TestResults/*.trx
            **/TestResults/*/*.trx

  docker:
    name: Build & push Docker images to GHCR
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set VERSION
        run: echo "VERSION=${{ env.VERSION_BASE }}.${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        run: echo "${{ secrets.GHCR_TOKEN }}" | docker login "$REGISTRY" -u "JugurthaDev" --password-stdin

      - name: Build and push images
        run: |
          set -euo pipefail

          REGISTRY_IMAGE="${REGISTRY}/${GITHUB_REPOSITORY,,}"

          echo "Using REGISTRY_IMAGE=$REGISTRY_IMAGE"
          echo "Building Docker images for version $VERSION"

          # ApiService
          docker build -f "$API_DOCKERFILE" -t "${REGISTRY_IMAGE}/apiservice:${VERSION}" .
          docker push "${REGISTRY_IMAGE}/apiservice:${VERSION}"

          docker tag "${REGISTRY_IMAGE}/apiservice:${VERSION}" "${REGISTRY_IMAGE}/apiservice:latest"
          docker push "${REGISTRY_IMAGE}/apiservice:latest"

          # WebApp
          docker build -f "$WEB_DOCKERFILE" -t "${REGISTRY_IMAGE}/webapp:${VERSION}" .
          docker push "${REGISTRY_IMAGE}/webapp:${VERSION}"

          docker tag "${REGISTRY_IMAGE}/webapp:${VERSION}" "${REGISTRY_IMAGE}/webapp:latest"
          docker push "${REGISTRY_IMAGE}/webapp:latest"

  deploy:
    name: Deploy to prod server
    runs-on: ubuntu-latest
    needs: docker
    if: github.ref == 'refs/heads/main'
    env:
      DEPLOY_PATH: "/root/workly"

    steps:
      - name: Set VERSION
        run: echo "VERSION=${{ env.VERSION_BASE }}.${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      - name: Write SSH key
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh

          cat > ~/.ssh/id_gha << 'EOF'
          ${{ secrets.SSH_PRIVATE_KEY }}
          EOF
          chmod 600 ~/.ssh/id_gha

      - name: Write known_hosts from secret (if provided)
        if: ${{ env.KNOWN_HOSTS != '' }}
        env:
          KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          echo "$KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Scan host to populate known_hosts (fallback)
        if: ${{ env.KNOWN_HOSTS == '' }}
        env:
          KNOWN_HOSTS: ${{ secrets.SSH_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          ssh-keyscan -p "${{ secrets.DEPLOY_SSH_PORT }}" "${{ secrets.DEPLOY_SSH_HOST }}" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Test SSH connectivity (debug)
        run: |
          set -euo pipefail
          ssh -vvv -i ~/.ssh/id_gha -p "${{ secrets.DEPLOY_SSH_PORT }}" "${{ secrets.DEPLOY_SSH_USER }}@${{ secrets.DEPLOY_SSH_HOST }}" "echo OK"

      - name: Deploy over SSH
        run: |
          set -euo pipefail

          REGISTRY_IMAGE="${REGISTRY}/${GITHUB_REPOSITORY,,}"
          CR="$REGISTRY"
          RU="${{ secrets.REGISTRY_USER }}"
          RP="${{ secrets.REGISTRY_PASSWORD }}"
          DP="$DEPLOY_PATH"
          TV="$VERSION"

          echo "Deploying version -> $TV"
          echo "Using REGISTRY_IMAGE=$REGISTRY_IMAGE"

          ssh -i ~/.ssh/id_gha -p "${{ secrets.DEPLOY_SSH_PORT }}" "${{ secrets.DEPLOY_SSH_USER }}@${{ secrets.DEPLOY_SSH_HOST }}" \
            "REGISTRY_IMAGE='$REGISTRY_IMAGE' CI_REGISTRY_IMAGE='$REGISTRY_IMAGE' CI_REGISTRY='$CR' REGISTRY_USER='$RU' REGISTRY_PASSWORD='$RP' DEPLOY_PATH='$DP' TAG='$TV' bash -s" << 'EOF'
          set -euo pipefail

          : "${REGISTRY_IMAGE:?missing REGISTRY_IMAGE}"
          : "${CI_REGISTRY_IMAGE:?missing CI_REGISTRY_IMAGE}"
          : "${CI_REGISTRY:?missing CI_REGISTRY}"
          : "${REGISTRY_USER:?missing REGISTRY_USER}"
          : "${REGISTRY_PASSWORD:?missing REGISTRY_PASSWORD}"
          : "${DEPLOY_PATH:?missing DEPLOY_PATH}"
          : "${TAG:?missing TAG}"

          cd "$DEPLOY_PATH"

          echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USER" --password-stdin "$CI_REGISTRY"

          docker compose pull
          docker compose up -d --remove-orphans

          docker image prune -f
          EOF

  tag_version:
    name: Tag repository with version
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 

      - name: Configure git
        run: |
          git config user.email "ci@github"
          git config user.name "GitHub Actions"

      - name: Set remote with token
        run: |
          git remote set-url origin "https://x-access-token:${{ secrets.REPO_PUSH_TOKEN }}@github.com/${GITHUB_REPOSITORY}.git"

      - name: Set VERSION
        run: echo "VERSION=${{ env.VERSION_BASE }}.${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      - name: Create and push tag
        run: |
          git fetch --tags
          if git tag | grep -qx "$VERSION"; then
            echo "Tag $VERSION already exists, skipping"
          else
            echo "Tagging repository with version $VERSION"
            git tag "$VERSION"
            git push origin "$VERSION"
          fi

